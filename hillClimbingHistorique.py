from random import *
from math import *

#traduction
def translate(s, alphabet):
    dict_alphabet = {}
    for i in range(len(alphabet)):
        dict_alphabet[alphabet[i]] = chr(i + 65)
    s_translated = ""
    for c in s:
        s_translated += dict_alphabet[c]
    return s_translated

#dico theorique:
def charge_table (fic):
    """Charge dans un dictionnaire les informations du fichier fic."""
    tab = dict()
    for ligne in fic:
        donnees = ligne.rstrip('\n\r').split(";")
        tab[donnees[0]] = int(donnees[1])
    return tab

def get_dict_theo(nom_fichier):
    return charge_table(open(nom_fichier, "r"))

"""
#dico theorique:
def get_dict_theo(nom_fichier):
    dico = {}
    workbook = xlrd.open_workbook(nom_fichier)
    worksheet = workbook.sheet_by_index(0)
    for i in range(65536): #196076
        dico[worksheet.cell(i, 0).value] = int(worksheet.cell(i, 1).value)
    return dico
"""
"""
#dico actuel:
def get_dico(alphabet, s, dict_theo):
    dict_alphabet = {}
    for i in range(len(alphabet)):
        dict_alphabet[alphabet[i]] = chr(i + 65)
    dict_s = {}
    s_translated = ""
    for c in s:
        s_translated += dict_alphabet[c]
    for i in range(len(s_translated)-3):
        ts = ""
        for j in range(4):
            ts += s_translated[i+j]
        if ts in dict_s:
            dict_s[ts] += 1
        else:
            dict_s[ts] = 1
    for key in dict_theo:
        if key not in dict_s:
            dict_s[key] = 0
    return dict_s
"""

#fitness function ancienne v1
"""
def fitness(alphabet, s):
    dict_theo = get_dict_theo('nb_tetra_fr.xls')
    dict_s = get_dico(alphabet, s, dict_theo)
    for key in dict_s:
        if key not in dict_theo:
            dict_theo[key] = 0
    somme = 0
    nb_tetra_t = 0
    nb_tetra_s = 0
    for tetra in dict_s:
        nb_tetra_s += dict_s[tetra]
    for tetra in dict_theo:
        nb_tetra_t += dict_theo[tetra]
    for tetra in dict_s:
        somme += abs((dict_s[tetra]/nb_tetra_s)-(dict_theo[tetra]/nb_tetra_t))
    return somme
"""
#fitness function ancienne v2
"""
def fitness(alphabet, s, dict_theo):
    dict_s = get_dico(alphabet, s, dict_theo)
    somme = 0
    nb_tetra_t = 0
    nb_tetra_s = 0
    for tetra in dict_s:
        nb_tetra_s += dict_s[tetra]
    for tetra in dict_theo:
        nb_tetra_t += dict_theo[tetra]
    for tetra in dict_s:
        if tetra in dict_theo:
            somme += abs((dict_s[tetra]/nb_tetra_s)-(dict_theo[tetra]/nb_tetra_t))
        else:
            somme += dict_s[tetra]/nb_tetra_s
    return somme
"""

"RTFGYHUJKDXRCFGVHBJNDXFCGVBHDFCGVHBRFDCGVHBJNFDCGVHBJNFDCGVHBJN"
#fitness function v3
def fitness(s, alphabet, dict_theo):
    somme = 0
    s_translated = translate(s, alphabet)
    for i in range(len(s_translated) - 3):
        ts = ""
        for j in range(4):
            ts += s_translated[i + j]
        if ts in dict_theo:
            somme += log10(dict_theo[ts])
        else:
            somme += 0.001
    return somme

def fitness_permutation_freq(s, alphabet, dict_theo):
    somme = 0
    s_translated = translate(s, alphabet)
    list_tetra = []
    list_freq = []
    total_theo = 0
    total_reel = 0

    for tetra in dict_theo:
        total_theo += dict_theo[tetra]

    for i in range(len(s_translated) - 3):
        ts = ""
        for j in range(4):
            ts += s_translated[i + j]
        if ts not in list_tetra:
            list_tetra.append(ts)
            list_freq.append(1)
        else:
            list_freq[list_tetra.index(ts)] += 1

    for nb in list_freq:
        total_reel += nb

    for tetra in dict_theo:
        if tetra in list_tetra:
            somme += abs((list_freq[list_tetra.index(tetra)]/total_reel) - (dict_theo[tetra]/total_theo))
        else:
            somme += dict_theo[tetra]/total_theo

    for tetra in list_tetra:
        if tetra not in dict_theo:
            somme += list_freq[list_tetra.index(tetra)]/total_reel

    return somme

#hill climbing

def swap(s, i, j):
    sf = ""
    for k in range(len(s)):
        if k != i and k != j:
            sf += s[k]
        elif k == i:
            sf += s[j]
        else:
            sf += s[i]
    return sf

def hill_climbing_permutation_1(s, epsilon = 0.5 ,alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"):
    dict_theo = get_dict_theo('nb_tetra_fr.csv')
    fit = fitness(s, alphabet, dict_theo)
    alpha = alphabet[:]
    #cpt = 0
    freeze = 0
    while freeze < 1000:
        #cpt += 1
        i, j = 0, 0
        while i == j:
            i = randint(0, len(alpha) - 1)
            j = randint(0, len(alpha) - 1)
        fit2 = fitness(s, swap(alpha, i, j), dict_theo)
        if (abs(fit - fit2) <= epsilon) or fit >= fit2:
            freeze += 1
        else:
            fit = fit2
            alpha = swap(alpha, i, j)
            freeze = 0
    #print("Nombre d'iterations : ", cpt)
    return alpha

def hill_climbing_permutation_2(s, epsilon = 0.005 ,alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"):
    dict_theo = get_dict_theo('nb_tetra_fr.csv')
    fit = fitness_permutation_freq(s, alphabet, dict_theo)
    alpha = alphabet[:]
    #cpt = 0
    freeze = 0
    while freeze < 10000:
        #cpt += 1
        i, j = 0, 0
        while i == j:
            i = randint(0, len(alpha) - 1)
            j = randint(0, len(alpha) - 1)
        fit2 = fitness(s, swap(alpha, i, j), dict_theo)
        if (abs(fit - fit2) <= epsilon) or fit <= fit2:
            freeze += 1
        else:
            fit = fit2
            alpha = swap(alpha, i, j)
            freeze = 0
    #print("Nombre d'iterations : ", cpt)
    return alpha


def multi_hill_climbing(n, s):
    for i in range(n):
        cle = hill_climbing_permutation_1(s)
        print(cle)
        print(translate(s, cle), "\n")

#multi_hill_climbing(2, "JZPQDUZUXIUONCDJWLXYOVUDTXDUCJDLJQTTYOAYODXZUXLUONKQYSRUXZUWYDUUTRUWDQJONEDJXZOWLUZJOTDUWJVJQUWTMJXDUKOUDUXMQDJWTLOKUKUMUTQTXYOGGZUKJZCDUZUVJSJDKUSJTRUDQWULYWWUKYQZJSRJWLUZZUSDQJKJRUOUZZUGQWQXXJQTLUEYOTYWWUDXJVUXTUUZZUMYDTJZJSRJWLUZZULJWXZUSJEQWUTZJQXXJWTXUXGDUDUXSRUDSRUDZUODXVUTUKUWTXJOMUOLUSZJDTUFOQVUWJQTLUZJMYDTU")

"""
_________
KPSNDSRVMPSHDTSPTTPRDMKPMRDPDCMBNYNDSRNVSHPTCPYPHTRNTSHPTNCEOHDWOMIPMNKNMSQVPKPTUPVFMOKSVHMPTRPTGNBTRPCNEOVDCCPPSRVUPH
NEKRPXIADJLCUMOGQHTSVYZFBW  B=H => NAKRPXIEDJLCUMOGQHTSVYZFBW  G=M => NAKRPXUEDJLCIMOGQHTSVYZFBW  G=J => NAKRPXJEDULCIMOGQHTSVYZFBW
_________
BKUEBVCKARHSSKMVKACKBKTSBNKQVTKKADLHTSKKAPRLVZUKQKTSHLVFTHVKTSCKAMHQDKACKJLHQQKAMPUFKASHTCVAZUKLKACKUESPUMADLUAHFHUBNKRMULHVKTSSPUSKARLKUKAKTDLKVTBVKLBPQQKCKASPMBNKAFKHTSKABKSHVSCUTKSMVASKAAKCVTBKTCVKVLTYHIHVSCHUSMKALKIKMACHASMKAHLNPMVOPTQKTHBHTSZUKBKAJKUETPBSUMTKACKADHYACKLHNPUVLLKKSCUJKMIPUAKSKADKUSKSMKCKLHRKLFVZUKMKDMVSCKMMVKMKKSVKTTKLKBNHMMKSVKMZUVKSHVSMKIKTUBKSSKJPVAVLTHQKTHVSZUKSMPVARKMLVTKAPTDPUIHVSSPUXPUMABULRUSKMBKLLKALHUTHBBVCKTSHMMVIKHLHBHFKCKESMHBSVPTUTKBMPUBHAAKHLLHVSHMMKSKMLKSMHIHVLDKTCHTSUTFMHTCZUHMSCNKUMKKTRHACUSKMMVUTAVLKTBKAKSHVSJHVSLKAQPULVTKUMATKRMHTLHVKTSDLUALKASMKSKHUECUTMPULKQKTSDMPLPTFKPTKTSKTCHVSAKULKQKTSAPMSVMCKLHJPAAKLKRMUVSLPVTSHVTCUTQHMSKHUSHDHTSAUMCKLHSPLKTPTXKAUVACUQVCVMKDPTCVSLKXKUTKNPQQKLKQHTPKUIMKHDMKAHIPVMIVCKLKARKMLVTKAAKSHVSHAAVAHSKMMKNKUMKUECKLHBBVCKTSKSVLFHMCHVSAHAHUIHFKMVKQUKSSKVLHIHVSAVQDLKQKTSLKIKCKFMPAYKUEKSKVTSAAUMLKBNHMMKSVKMBPQQKFKTKDHMSHTSCKDHMPLKABKCKMTVKMKTKJJKSTKTCVAHVSDHAAVLPTFCNHRVSUCKVLJHLLHVSZUKLKIVAHFKCKLVTBPTTULUVBPTIVTSKSZUVLJUSDMVACUTKCKBKACKQHTFKHVAPTACKBPTJVCKTBKAZUVJPTSDHMJPVABHUAKMLKAIVKVLLKAFKTASPUSAKULAHNHUSKIPVE
HRBCKJFNVXWLQTPDZMASUIGEYO
CEUXCIDESBATTERIESDECENTCHEMINEESPLANTEESOBLIQUEMENTALIGNAIENTDESRAMPESDEFLAMMESROUGESTANDISQUELESDEUXTOURSPLUSAGAUCHEBRULAIENTTOUTESBLEUESENPLEINCIELCOMMEDESTORCHESGEANTESCETAITDUNETRISTESSEDINCENDIEILNYAVAITDAUTRESLEVERSDASTRESALHORIZONMENACANTQUECESFEUXNOCTURNESDESPAYSDELAHOUILLEETDUFERVOUSETESPEUTETREDELABELGIQUEREPRITDERRIEREETIENNELECHARRETIERQUIETAITREVENUCETTEFOISILNAMENAITQUETROISBERLINESONPOUVAITTOUJOURSCULBUTERCELLESLAUNACCIDENTARRIVEALACAGEDEXTRACTIONUNECROUCASSEALLAITARRETERLETRAVAILPENDANTUNGRANDQUARTDHEUREENBASDUTERRIUNSILENCESETAITFAITLESMOULINEURSNEBRANLAIENTPLUSLESTRETEAUXDUNROULEMENTPROLONGEONENTENDAITSEULEMENTSORTIRDELAFOSSELEBRUITLOINTAINDUNMARTEAUTAPANTSURDELATOLENONJESUISDUMIDIREPONDITLEJEUNEHOMMELEMANOEUVREAPRESAVOIRVIDELESBERLINESSETAITASSISATERREHEUREUXDELACCIDENTETILGARDAITSASAUVAGERIEMUETTEILAVAITSIMPLEMENTLEVEDEGROSYEUXETEINTSSURLECHARRETIERCOMMEGENEPARTANTDEPAROLESCEDERNIERENEFFETNENDISAITPASSILONGDHABITUDEILFALLAITQUELEVISAGEDELINCONNULUICONVINTETQUILFUTPRISDUNEDECESDEMANGEAISONSDECONFIDENCESQUIFONTPARFOISCAUSERLESVIEILLESGENSTOUTSEULSAHAUTEVOIX
_________
VWMCVZPWHNLSSWRZWHPWVWOSVBWUZOWWHDELOSWWHXNEZQMWUWOSLEZKOLZWOSPWHRLUDWHPWFELUUWHRXMKWHSLOPZHQMWEWHPWMCSXMRHDEMHLKLMVBWNRMELZWOSSXMSWHNEWMWHWODEWZOVZWEVXUUWPWHSXRVBWHKWLOSWHVWSLZSPMOWSRZHSWHHWPZOVWOPZWZEOGLYLZSPLMSRWHEWYWRHPLHSRWHLEBXRZJXOUWOLVLOSQMWVWHFWMCOXVSMROWHPWHDLGHPWELBXMZEEWWSPMFWRYXMHWSWHDWMSWSRWPWELNWEKZQMWRWDRZSPWRRZWRWWSZWOOWEWVBLRRWSZWRQMZWSLZSRWYWOMVWSSWFXZHZEOLUWOLZSQMWSRXZHNWREZOWHXODXMYLZSSXMIXMRHVMENMSWRVWEEWHELMOLVVZPWOSLRRZYWLELVLKWPWCSRLVSZXOMOWVRXMVLHHWLEELZSLRRWSWREWSRLYLZEDWOPLOSMOKRLOPQMLRSPBWMRW
LNVPWFKBZIAEUOXDQRHSMYTCGJ
CEUXCIDESBATTERIESDECENTCHEMINEESPLANTEESOBLIQUEMENTALIGNAIENTDESRAMPESDEFLAMMESROUGESTANDISQUELESDEUXTOURSPLUSAGAUCHEBRULAIENTTOUTESBLEUESENPLEINCIELCOMMEDESTORCHESGEANTESCETAITDUNETRISTESSEDINCENDIEILNYAVAITDAUTRESLEVERSDASTRESALHORIZONMENACANTQUECESFEUXNOCTURNESDESPAYSDELAHOUILLEETDUFERVOUSETESPEUTETREDELABELGIQUEREPRITDERRIEREETIENNELECHARRETIERQUIETAITREVENUCETTEFOISILNAMENAITQUETROISBERLINESONPOUVAITTOUJOURSCULBUTERCELLESLAUNACCIDENTARRIVEALACAGEDEXTRACTIONUNECROUCASSEALLAITARRETERLETRAVAILPENDANTUNGRANDQUARTDHEURE
_________
"""
#print(translate("KPSNDSRVMPSHDTSPTTPRDMKPMRDPDCMBNYNDSRNVSHPTCPYPHTRNTSHPTNCEOHDWOMIPMNKNMSQVPKPTUPVFMOKSVHMPTRPTGNBTRPCNEOVDCCPPSRVUPH", "NAKRPXJEDULCIMOGQHTSVYZFBW"))

def transposition(message, cle, char_padding):

    #copie du str message
    msg = message[:]

    #ajouter les caractères au message pour effectuer le padding, si nécessaire
    if (len(msg) % len(cle)) != 0:
        for i in range(len(cle) - (len(msg) % len(cle))):
            msg += char_padding

    #creation de la matrice du clair
    matrice_cl = []
    for i in range(len(msg) // len(cle)):
        tmp_str = ""
        for j in range(len(cle)):
            tmp_str += msg[i*len(cle)+j]
        matrice_cl.append(tmp_str)

    #creation du message final (chiffré)
    msg_fin = ""
    for i in range(len(cle)):
        for j in range(len(msg) // len(cle)):
            msg_fin += matrice_cl[j][int(cle[i])-1]

    #retour du message final
    return msg_fin

def dechiffrement_transposition(message, cle, char_padding="&"):

    #copie du message chiffré
    msg = message[:]

    #creation de la matrice du chiffré
    matrice_ch = []
    for i in range(len(cle)):
        tmp_str = ""
        for j in range(len(msg) // len(cle)):
            tmp_str += msg[i*(len(msg) // len(cle))+j]
        matrice_ch.append(tmp_str)

    #creation du message final (déchiffré)
    msg_fin = ""
    for i in range(len(msg) // len(cle)):
        for j in range(len(cle)):
            msg_fin += matrice_ch[cle.index(str(j+1))][i]

    #clean des lettres ajoutées pour le padding & retour du message final
    '''msg_fin_clean = ""
    for c in msg_fin:
        if c != char_padding:
            msg_fin_clean += c
    '''
    #retour du message
    return msg_fin

def suppr_lettre(msg, c):
    strfinal = ""
    for e in msg:
        if e != c:
            strfinal += e
    return strfinal

def fitness_transposition_1(message, cle, char_padding, dict_theo):
    somme = 0
    msg = dechiffrement_transposition(message, cle, char_padding)
    index = 1

    while (msg[-index] == char_padding):
        somme += 1000
        if (index+1 != len(msg)):
            index += 1
    msgclean = suppr_lettre(msg, char_padding)

    for i in range(len(msgclean) - 3):
        ts = ""
        for j in range(4):
            ts += msgclean[i + j]
        if ts in dict_theo:
            somme += log10(dict_theo[ts])
        else:
            somme += 0.001

    return somme

def nb_padding_manquant(msg_dechiffre, char_padding):
    nb_char_pdg = 0
    for e in msg_dechiffre:
        if e == char_padding:
            nb_char_pdg += 1
    for i in range(1, nb_char_pdg + 1):
        if msg_dechiffre[-i] == char_padding:
            nb_char_pdg -= 1
    return nb_char_pdg

def hill_climbing_transposition_taillefixe(message, char_padding = "&", cle = "123456789", epsilon = 0.5):
    #copie de la clé et du message
    key = cle[:]
    msg = message[:]

    #chargement du dictionnaire théorique
    dict_theo = get_dict_theo('nb_tetra_fr.csv')

    #initialisation des valeurs initiales de fit et de freeze
    msg_dechiffre = dechiffrement_transposition(msg, key, char_padding)
    nb_pdg = nb_padding_manquant(msg_dechiffre, char_padding)

    #on commence par poser la condition de rassembler les caractères de padding à la fin
    while nb_pdg != 0:
        i, j = 0, 0
        while i == j:
            i = randint(0, len(key) - 1)
            j = randint(0, len(key) - 1)
        msg_dechiffre = dechiffrement_transposition(msg, swap(key, i, j), char_padding)
        nb_pdg2 = nb_padding_manquant(msg_dechiffre, char_padding)
        if nb_pdg2 <= nb_pdg:
            nb_pdg = nb_pdg2
            key = swap(key, i, j)

    #initialisation des valeurs initiales de fit et de freeze
    fit = fitness_transposition_1(msg, key, char_padding, dict_theo)
    freeze = 0

    #boucle principale
    while freeze < 15000:
        i, j = 0, 0
        while i == j:
            i = randint(0, len(key) - 1)
            j = randint(0, len(key) - 1)
        fit2 = fitness_transposition_1(msg, swap(key, i, j), char_padding, dict_theo)
        if (abs(fit - fit2) <= epsilon) or fit >= fit2:
            freeze += 1
        else:
            fit = fit2
            key = swap(key, i, j)
            freeze = 0
    return key



#print(transposition("MAISDISDONCONNESTQUANDMEMEPASVENUSPOURBEURRERLESSANDWICHS", "587139246", "X"))
"""
for i in range(10):
    cle = hill_climbing_transposition_taillefixe(transposition("CEUXCIDESBATTERIESDECENTCHEMINEESPLANTEESOBLIQUEMENTALIGNAIENTDESRAMPESDEFLAMMESROUGESTANDISQUELESDEUXTOURSPLUSAGAUCHEBRULAIENTTOUTESBLEUESENPLEINCIELCOMMEDESTORCHESGEANTESCETAITDUNETRISTESSEDINCENDIEILNYAVAITDAUTRESLEVERSDASTRESALHORIZONMENACANTQUECESFEUXNOCTURNESDESPAYSDELAHOUILLEETDUFERVOUSETESPEUTETREDELABELGIQUEREPRITDERRIEREETIENNELECHARRETIERQUIETAITREVENUCETTEFOISILNAMENAITQUETROISBERLINESONPOUVAITTOUJOURSCULBUTERCELLESLAUNACCIDENTARRIVEALACAGEDEXTRACTIONUNECROUCASSEALLAITARRETERLETRAVAILPENDANTUNGRANDQUARTDHEUREENBASDUTERRIUNSILENCESETAITFAITLESMOULINEURSNEBRANLAIENTPLUSLESTRETEAUXDUNROULEMENTPROLONGEONENTENDAITSEULEMENTSORTIRDELAFOSSELEBRUITLOINTAINDUNMARTEAUTAPANTSURDELATOLENONJESUISDUMIDIREPONDITLEJEUNEHOMMELEMANOEUVREAPRESAVOIRVIDELESBERLINESSETAITASSISATERREHEUREUXDELACCIDENTETILGARDAITSASAUVAGERIEMUETTEILAVAITSIMPLEMENTLEVEDEGROSYEUXETEINTSSURLECHARRETIERCOMMEGENEPARTANTDEPAROLESCEDERNIERENEFFETNENDISAITPASSILONGDHABITUDEILFALLAITQUELEVISAGEDELINCONNULUICONVINTETQUILFUTPRISDUNEDECESDEMANGEAISONSDECONFIDENCESQUIFONTPARFOISCAUSERLESVIEILLESGENSTOUTSEULSAHAUTEVOIX", "587139246", "&"))
    print(dechiffrement_transposition(transposition("CEUXCIDESBATTERIESDECENTCHEMINEESPLANTEESOBLIQUEMENTALIGNAIENTDESRAMPESDEFLAMMESROUGESTANDISQUELESDEUXTOURSPLUSAGAUCHEBRULAIENTTOUTESBLEUESENPLEINCIELCOMMEDESTORCHESGEANTESCETAITDUNETRISTESSEDINCENDIEILNYAVAITDAUTRESLEVERSDASTRESALHORIZONMENACANTQUECESFEUXNOCTURNESDESPAYSDELAHOUILLEETDUFERVOUSETESPEUTETREDELABELGIQUEREPRITDERRIEREETIENNELECHARRETIERQUIETAITREVENUCETTEFOISILNAMENAITQUETROISBERLINESONPOUVAITTOUJOURSCULBUTERCELLESLAUNACCIDENTARRIVEALACAGEDEXTRACTIONUNECROUCASSEALLAITARRETERLETRAVAILPENDANTUNGRANDQUARTDHEUREENBASDUTERRIUNSILENCESETAITFAITLESMOULINEURSNEBRANLAIENTPLUSLESTRETEAUXDUNROULEMENTPROLONGEONENTENDAITSEULEMENTSORTIRDELAFOSSELEBRUITLOINTAINDUNMARTEAUTAPANTSURDELATOLENONJESUISDUMIDIREPONDITLEJEUNEHOMMELEMANOEUVREAPRESAVOIRVIDELESBERLINESSETAITASSISATERREHEUREUXDELACCIDENTETILGARDAITSASAUVAGERIEMUETTEILAVAITSIMPLEMENTLEVEDEGROSYEUXETEINTSSURLECHARRETIERCOMMEGENEPARTANTDEPAROLESCEDERNIERENEFFETNENDISAITPASSILONGDHABITUDEILFALLAITQUELEVISAGEDELINCONNULUICONVINTETQUILFUTPRISDUNEDECESDEMANGEAISONSDECONFIDENCESQUIFONTPARFOISCAUSERLESVIEILLESGENSTOUTSEULSAHAUTEVOIX", "587139246", "&"), cle, "&"))
"""
#dict_theo = get_dict_theo('nb_tetra_fr.csv')

cle = hill_climbing_transposition_taillefixe(transposition("MAISDISDONCONNESTQUANDMEMEPASVENUSPOURBEURRERLESSANDWICHS", "587139246", "&"))
#print(dechiffrement_transposition(transposition("MAISDISDONCONNESTQUANDMEMEPASVENUSPOURBEURRERLESSANDWICHS", "587139246", "&"), cle, "&"))

#print(translate("BKUEBVCKARHSSKMVKACKBKTSBNKQVTKKADLHTSKKAPRLVZUKQKTSHLVFTHVKTSCKAMHQDKACKJLHQQKAMPUFKASHTCVAZUKLKACKUESPUMADLUAHFHUBNKRMULHVKTSSPUSKARLKUKAKTDLKVTBVKLBPQQKCKASPMBNKAFKHTSKABKSHVSCUTKSMVASKAAKCVTBKTCVKVLTYHIHVSCHUSMKALKIKMACHASMKAHLNPMVOPTQKTHBHTSZUKBKAJKUETPBSUMTKACKADHYACKLHNPUVLLKKSCUJKMIPUAKSKADKUSKSMKCKLHRKLFVZUKMKDMVSCKMMVKMKKSVKTTKLKBNHMMKSVKMZUVKSHVSMKIKTUBKSSKJPVAVLTHQKTHVSZUKSMPVARKMLVTKAPTDPUIHVSSPUXPUMABULRUSKMBKLLKALHUTHBBVCKTSHMMVIKHLHBHFKCKESMHBSVPTUTKBMPUBHAAKHLLHVSHMMKSKMLKSMHIHVLDKTCHTSUTFMHTCZUHMSCNKUMKKTRHACUSKMMVUTAVLKTBKAKSHVSJHVSLKAQPULVTKUMATKRMHTLHVKTSDLUALKASMKSKHUECUTMPULKQKTSDMPLPTFKPTKTSKTCHVSAKULKQKTSAPMSVMCKLHJPAAKLKRMUVSLPVTSHVTCUTQHMSKHUSHDHTSAUMCKLHSPLKTPTXKAUVACUQVCVMKDPTCVSLKXKUTKNPQQKLKQHTPKUIMKHDMKAHIPVMIVCKLKARKMLVTKAAKSHVSHAAVAHSKMMKNKUMKUECKLHBBVCKTSKSVLFHMCHVSAHAHUIHFKMVKQUKSSKVLHIHVSAVQDLKQKTSLKIKCKFMPAYKUEKSKVTSAAUMLKBNHMMKSVKMBPQQKFKTKDHMSHTSCKDHMPLKABKCKMTVKMKTKJJKSTKTCVAHVSDHAAVLPTFCNHRVSUCKVLJHLLHVSZUKLKIVAHFKCKLVTBPTTULUVBPTIVTSKSZUVLJUSDMVACUTKCKBKACKQHTFKHVAPTACKBPTJVCKTBKAZUVJPTSDHMJPVABHUAKMLKAIVKVLLKAFKTASPUSAKULAHNHUSKIPVE", hill_climbing_permutation_1("BKUEBVCKARHSSKMVKACKBKTSBNKQVTKKADLHTSKKAPRLVZUKQKTSHLVFTHVKTSCKAMHQDKACKJLHQQKAMPUFKASHTCVAZUKLKACKUESPUMADLUAHFHUBNKRMULHVKTSSPUSKARLKUKAKTDLKVTBVKLBPQQKCKASPMBNKAFKHTSKABKSHVSCUTKSMVASKAAKCVTBKTCVKVLTYHIHVSCHUSMKALKIKMACHASMKAHLNPMVOPTQKTHBHTSZUKBKAJKUETPBSUMTKACKADHYACKLHNPUVLLKKSCUJKMIPUAKSKADKUSKSMKCKLHRKLFVZUKMKDMVSCKMMVKMKKSVKTTKLKBNHMMKSVKMZUVKSHVSMKIKTUBKSSKJPVAVLTHQKTHVSZUKSMPVARKMLVTKAPTDPUIHVSSPUXPUMABULRUSKMBKLLKALHUTHBBVCKTSHMMVIKHLHBHFKCKESMHBSVPTUTKBMPUBHAAKHLLHVSHMMKSKMLKSMHIHVLDKTCHTSUTFMHTCZUHMSCNKUMKKTRHACUSKMMVUTAVLKTBKAKSHVSJHVSLKAQPULVTKUMATKRMHTLHVKTSDLUALKASMKSKHUECUTMPULKQKTSDMPLPTFKPTKTSKTCHVSAKULKQKTSAPMSVMCKLHJPAAKLKRMUVSLPVTSHVTCUTQHMSKHUSHDHTSAUMCKLHSPLKTPTXKAUVACUQVCVMKDPTCVSLKXKUTKNPQQKLKQHTPKUIMKHDMKAHIPVMIVCKLKARKMLVTKAAKSHVSHAAVAHSKMMKNKUMKUECKLHBBVCKTSKSVLFHMCHVSAHAHUIHFKMVKQUKSSKVLHIHVSAVQDLKQKTSLKIKCKFMPAYKUEKSKVTSAAUMLKBNHMMKSVKMBPQQKFKTKDHMSHTSCKDHMPLKABKCKMTVKMKTKJJKSTKTCVAHVSDHAAVLPTFCNHRVSUCKVLJHLLHVSZUKLKIVAHFKCKLVTBPTTULUVBPTIVTSKSZUVLJUSDMVACUTKCKBKACKQHTFKHVAPTACKBPTJVCKTBKAZUVJPTSDHMJPVABHUAKMLKAIVKVLLKAFKTASPUSAKULAHNHUSKIPVE")))
#print("CEUXCIDESBATTERIESDECENTCHEMINEESPLANTEESOBLIQUEMENTALIGNAIENTDESRAMPESDEFLAMMESROUGESTANDISQUELESDEUXTOURSPLUSAGAUCHEBRULAIENTTOUTESBLEUESENPLEINCIELCOMMEDESTORCHESGEANTESCETAITDUNETRISTESSEDINCENDIEILNYAVAITDAUTRESLEVERSDASTRESALHORIZONMENACANTQUECESFEUXNOCTURNESDESPAYSDELAHOUILLEETDUFERVOUSETESPEUTETREDELABELGIQUEREPRITDERRIEREETIENNELECHARRETIERQUIETAITREVENUCETTEFOISILNAMENAITQUETROISBERLINESONPOUVAITTOUJOURSCULBUTERCELLESLAUNACCIDENTARRIVEALACAGEDEXTRACTIONUNECROUCASSEALLAITARRETERLETRAVAILPENDANTUNGRANDQUARTDHEUREENBASDUTERRIUNSILENCESETAITFAITLESMOULINEURSNEBRANLAIENTPLUSLESTRETEAUXDUNROULEMENTPROLONGEONENTENDAITSEULEMENTSORTIRDELAFOSSELEBRUITLOINTAINDUNMARTEAUTAPANTSURDELATOLENONJESUISDUMIDIREPONDITLEJEUNEHOMMELEMANOEUVREAPRESAVOIRVIDELESBERLINESSETAITASSISATERREHEUREUXDELACCIDENTETILGARDAITSASAUVAGERIEMUETTEILAVAITSIMPLEMENTLEVEDEGROSYEUXETEINTSSURLECHARRETIERCOMMEGENEPARTANTDEPAROLESCEDERNIERENEFFETNENDISAITPASSILONGDHABITUDEILFALLAITQUELEVISAGEDELINCONNULUICONVINTETQUILFUTPRISDUNEDECESDEMANGEAISONSDECONFIDENCESQUIFONTPARFOISCAUSERLESVIEILLESGENSTOUTSEULSAHAUTEVOIX")
#print(translate("BKUEBVCKARHSSKMVKACKBKTSBNKQVTKKADLHTSKKAPRLVZUKQKTSHLVFTHVKTSCKAMHQDKACKJLHQQKAMPUFKASHTCVAZUKLKACKUESPUMADLUAHFHUBNKRMULHVKTSSPUSKARLKUKAKTDLKVTBVKLBPQQKCKASPMBNKAFKHTSKABKSHVSCUTKSMVASKAAKCVTBKTCVKVLTYHIHVSCHUSMKALKIKMACHASMKAHLNPMVOPTQKTHBHTSZUKBKAJKUETPBSUMTKACKADHYACKLHNPUVLLKKSCUJKMIPUAKSKADKUSKSMKCKLHRKLFVZUKMKDMVSCKMMVKMKKSVKTTKLKBNHMMKSVKMZUVKSHVSMKIKTUBKSSKJPVAVLTHQKTHVSZUKSMPVARKMLVTKAPTDPUIHVSSPUXPUMABULRUSKMBKLLKALHUTHBBVCKTSHMMVIKHLHBHFKCKESMHBSVPTUTKBMPUBHAAKHLLHVSHMMKSKMLKSMHIHVLDKTCHTSUTFMHTCZUHMSCNKUMKKTRHACUSKMMVUTAVLKTBKAKSHVSJHVSLKAQPULVTKUMATKRMHTLHVKTSDLUALKASMKSKHUECUTMPULKQKTSDMPLPTFKPTKTSKTCHVSAKULKQKTSAPMSVMCKLHJPAAKLKRMUVSLPVTSHVTCUTQHMSKHUSHDHTSAUMCKLHSPLKTPTXKAUVACUQVCVMKDPTCVSLKXKUTKNPQQKLKQHTPKUIMKHDMKAHIPVMIVCKLKARKMLVTKAAKSHVSHAAVAHSKMMKNKUMKUECKLHBBVCKTSKSVLFHMCHVSAHAHUIHFKMVKQUKSSKVLHIHVSAVQDLKQKTSLKIKCKFMPAYKUEKSKVTSAAUMLKBNHMMKSVKMBPQQKFKTKDHMSHTSCKDHMPLKABKCKMTVKMKTKJJKSTKTCVAHVSDHAAVLPTFCNHRVSUCKVLJHLLHVSZUKLKIVAHFKCKLVTBPTTULUVBPTIVTSKSZUVLJUSDMVACUTKCKBKACKQHTFKHVAPTACKBPTJVCKTBKAZUVJPTSDHMJPVABHUAKMLKAIVKVLLKAFKTASPUSAKULAHNHUSKIPVE", hill_climbing_permutation_2("BKUEBVCKARHSSKMVKACKBKTSBNKQVTKKADLHTSKKAPRLVZUKQKTSHLVFTHVKTSCKAMHQDKACKJLHQQKAMPUFKASHTCVAZUKLKACKUESPUMADLUAHFHUBNKRMULHVKTSSPUSKARLKUKAKTDLKVTBVKLBPQQKCKASPMBNKAFKHTSKABKSHVSCUTKSMVASKAAKCVTBKTCVKVLTYHIHVSCHUSMKALKIKMACHASMKAHLNPMVOPTQKTHBHTSZUKBKAJKUETPBSUMTKACKADHYACKLHNPUVLLKKSCUJKMIPUAKSKADKUSKSMKCKLHRKLFVZUKMKDMVSCKMMVKMKKSVKTTKLKBNHMMKSVKMZUVKSHVSMKIKTUBKSSKJPVAVLTHQKTHVSZUKSMPVARKMLVTKAPTDPUIHVSSPUXPUMABULRUSKMBKLLKALHUTHBBVCKTSHMMVIKHLHBHFKCKESMHBSVPTUTKBMPUBHAAKHLLHVSHMMKSKMLKSMHIHVLDKTCHTSUTFMHTCZUHMSCNKUMKKTRHACUSKMMVUTAVLKTBKAKSHVSJHVSLKAQPULVTKUMATKRMHTLHVKTSDLUALKASMKSKHUECUTMPULKQKTSDMPLPTFKPTKTSKTCHVSAKULKQKTSAPMSVMCKLHJPAAKLKRMUVSLPVTSHVTCUTQHMSKHUSHDHTSAUMCKLHSPLKTPTXKAUVACUQVCVMKDPTCVSLKXKUTKNPQQKLKQHTPKUIMKHDMKAHIPVMIVCKLKARKMLVTKAAKSHVSHAAVAHSKMMKNKUMKUECKLHBBVCKTSKSVLFHMCHVSAHAHUIHFKMVKQUKSSKVLHIHVSAVQDLKQKTSLKIKCKFMPAYKUEKSKVTSAAUMLKBNHMMKSVKMBPQQKFKTKDHMSHTSCKDHMPLKABKCKMTVKMKTKJJKSTKTCVAHVSDHAAVLPTFCNHRVSUCKVLJHLLHVSZUKLKIVAHFKCKLVTBPTTULUVBPTIVTSKSZUVLJUSDMVACUTKCKBKACKQHTFKHVAPTACKBPTJVCKTBKAZUVJPTSDHMJPVABHUAKMLKAIVKVLLKAFKTASPUSAKULAHNHUSKIPVE")))